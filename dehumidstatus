#!/usr/bin/python -W ignore
# -*- coding: utf-8 -*-
"""
A munin plugin for visualizing the status of Twitter-enabled dehumidifiers.

Name as follows:
/etc/munin/plugins/dehumid_<dehumidifiername>
where <dehumidifiername> is the name of the dehumidifier.

Currently supports:
    mwwdehumid http://github.com/mwalling/arduino-twitdehumid/tree
    hoopydehumid Arduino-based water level probe

Returns 0 for an empty dehumidifier, 100 for a full dehumidifier, or a
percentage in between where available.

Ryan Tucker <rtucker@gmail.com>
"""

import os
import re
import serial
import sys
import time


try:
    import twitter
    __twitterok__ = True
except ImportError:
    __twitterok__ = False

# Full and empty regexps for various dehumidifiers
__dehumidifiers__ = {
    'mwwdehumid':
        {'type': 'twitter',
         'full': 'My tank is full.*',
         'empty': 'Thanks for emptying me.*',
         'warn': False},
    'hoopydehumid':
        {'type': 'capacitance',
         'description': 'Basement Dehumidifier',
         'serial': '/dev/ttyUSB0',
         'numcaps': 10,
         'capvalue': 0.1e-6,
         'warn': True}
    }

class _FixedFileCache(twitter._FileCache):
    """Patches twitter._FileCache._GetUsername to include a try/except, to
       rectify http://github.com/rtucker/munin-dehumid-status/issues#issue/1"""
    def _GetUsername(self):
        """Attempt to find the username in a cross-platform fashion (modified
           by dehumidstatus)"""
        try:
            return os.getenv('USER') or \
                   os.getenv('LOGNAME') or \
                   os.getenv('USERNAME') or \
                   os.getlogin() or \
                   'nobody'
        except (IOError, OSError):
            return 'nobody'

twitter._FileCache = _FixedFileCache

def print_config(name):
    """outputs the configuration for a given dehumidifier"""
    if __dehumidifiers__[name]['type'] == 'twitter':
        api = twitter.Api()
        user = api.GetUser(name)
        desc = user.name + ' (via Twitter)'
    elif __dehumidifiers__[name]['type'] == 'capacitance':
        desc = __dehumidifiers__[name]['description'] + ' (via Arduino)'
    print """graph_title Status for %s
graph_args --base 1000 --lower-limit 0
graph_vlabel Fullness (percent)
graph_category Climate
graph_info Fullness of the dehumidifier
%s.min 0
%s.max 100
%s.label Percent full
%s.draw AREA""" % (desc, name, name, name, name)
    if __dehumidifiers__[name]['warn']:
        print """%s.warning 90\n%s.critical 100""" % (name, name)

def get_fullness_via_twitter(name):
    """queries twitter to receive a dehumidifier's fullness"""
    api = twitter.Api()
    user = api.GetUser(name)
    # returns the percent full from twitter
    text = user.status.text
    # Is it full?
    _rg = re.compile(__dehumidifiers__[name]['full'])
    if _rg.match(text):
        return 100
    # Is it empty?
    _rg = re.compile(__dehumidifiers__[name]['empty'])
    if _rg.match(text):
        return 0
    # Is it... neither?
    return 50

def get_fullness_via_capacitance(name):
    """determines the fullness of a dehumidifier by getting the capacitance
       via serial, then judging how full it really is"""

    # Query the Arduino for capacitance (time out after 10 seconds)
    loopstart = time.time()
    ser = serial.Serial(__dehumidifiers__[name]['serial'], 9600)
    ser.flush()
    results = []
    for test in range(0, 11):
        _ok = False
        while not _ok:
            if time.time() > loopstart+10:
                _ok = True
                break
            row = ser.readline().split()
            # Make sure we have 4 elements (didn't open at bad time)...
            if len(row) == 4:
                # row = [milliseconds, 'mS', capacitance, 'mumbleFarads']
                if row[3] == 'microFarads':
                    results.append(int(row[2]) * 1e-6)
                    sys.stderr.write('%suF, ' % row[2])
                    _ok = True
                elif row[3] == 'nanoFarads':
                    results.append(int(row[2]) * 1e-9)
                    sys.stderr.write('%snF, ' % row[2])
                    _ok = True
                else:
                    sys.stderr.write('try %i failed, ' % test)
    sys.stderr.write('done.\n')
    ser.close()

    if len(results) >= 5:
        # Pick the median
        capacitance = sorted(results)[int(len(results)/2)]
    else:
        # We did not get 5 values out; abort since our data is likely bad
        return None

    sys.stderr.write('Raw capacitance: %.2e, ' % capacitance)

    # Math thanks to Dawn Lepard <dawn@lepard.ca>:
    # Ctotal = 1/(n*(1/C)), solving for n gives us n = C/Ctotal
    # we ghetto-floor it, /* add 1 for the cap that will never be immersed, */
    # sub it from numcaps to get the quantity of capacitors immersed,
    # and multiply it to turn it into a percentage!
    numcaps = __dehumidifiers__[name]['numcaps']
    capvalue = __dehumidifiers__[name]['capvalue']
    immersed = numcaps - int((capvalue/capacitance) + 0.5)
    waterlevel = (immersed/float(numcaps-1))*100

    if immersed <= 0:
        # very little capacitance -- bottom of probe isn't even wet
        sys.stderr.write('empty!\n')
        return 0
    elif capacitance > (1/(2*(1/capvalue))):
        # Capacitance is greater than we'd see with 2 caps in series
        sys.stderr.write('full!\n')
        return 100
    else:
        sys.stderr.write('%i capacitors immersed\n' % immersed)
        return waterlevel

def main():
    """main function to handle munin fun"""
    myname = os.path.split(sys.argv[0])[-1].split('_')[1]
    if len(sys.argv) > 1 and sys.argv[1] == 'config':
        print_config(myname)
    else:
        if __dehumidifiers__[myname]['type'] == 'twitter':
            if __twitterok__:
                fullness = get_fullness_via_twitter(myname)
            else:
                raise ImportError('Twitter module not found for %s' % myname)
        elif __dehumidifiers__[myname]['type'] == 'capacitance':
            fullness = get_fullness_via_capacitance(myname)
        print '%s.value %i' % (myname, fullness)

if __name__ == '__main__':
    main()

