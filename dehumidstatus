#!/usr/bin/python -W ignore
# -*- coding: utf-8 -*-
"""
A munin plugin for visualizing the status of Twitter-enabled dehumidifiers.

Name as follows:
/etc/munin/plugins/dehumid_<dehumidifiername>
where <dehumidifiername> is the name of the dehumidifier.

Currently supports:
    mwwdehumid http://github.com/mwalling/arduino-twitdehumid/tree
    hoopydehumid Arduino-based water level probe

Returns 0 for an empty dehumidifier, 100 for a full dehumidifier, or a
percentage in between where available.

Ryan Tucker <rtucker@gmail.com>
"""

import os
import random
import re
import serial
import sys
import time


try:
    import twitter
    __twitterok__ = True
except ImportError:
    __twitterok__ = False

# Full and empty regexps for various dehumidifiers
__dehumidifiers__ = {
    'mwwdehumid':
        {'type': 'twitter',
         'full': 'My tank is full.*',
         'empty': 'Thanks for emptying me.*',
         'warn': False},
    'hoopydehumid':
        {'type': 'capacitance',
         'description': 'Basement Dehumidifier',
         'level': 'Tank is (\d+)',
         'serial': '/dev/ttyUSB0',
         'numcaps': 10,
         'capvalue': 0.1e-6,
         'showraw': False,
         'warn': True,
         'updatetwitter': 'Tank is %i%% full'}
    }

class _FixedFileCache(twitter._FileCache):
    """Patches twitter._FileCache._GetUsername to include a try/except, to
       rectify http://github.com/rtucker/munin-dehumid-status/issues#issue/1"""
    def _GetUsername(self):
        """Attempt to find the username in a cross-platform fashion (modified
           by dehumidstatus)"""
        try:
            return os.getenv('USER') or \
                   os.getenv('LOGNAME') or \
                   os.getenv('USERNAME') or \
                   os.getlogin() or \
                   'nobody'
        except (IOError, OSError):
            return 'nobody'

twitter._FileCache = _FixedFileCache

def print_config(name):
    """outputs the configuration for a given dehumidifier"""
    if __dehumidifiers__[name]['type'] == 'twitter':
        api = twitter.Api()
        user = api.GetUser(name)
        desc = user.name + ' (via Twitter)'
    elif __dehumidifiers__[name]['type'] == 'capacitance':
        desc = __dehumidifiers__[name]['description'] + ' (via Arduino)'
    print """graph_title Status for %s
graph_args --base 1000 --lower-limit 0
graph_vlabel Fullness (percent)
graph_category Climate
graph_info Fullness of the dehumidifier
%s.min 0
%s.max 100
%s.label Percent full
%s.draw AREA""" % (desc, name, name, name, name)
    if __dehumidifiers__[name]['warn']:
        print """%s.warning 90\n%s.critical 100""" % (name, name)
    if (__dehumidifiers__[name]['type'] == 'capacitance' and
        __dehumidifiers__[name]['showraw'] == True):
        print """raw.min 0\nraw.max 100\nraw.label Percent full (raw)"""

def get_fullness_via_twitter(name):
    """queries twitter to receive a dehumidifier's fullness"""
    api = twitter.Api()
    user = api.GetUser(name)
    # returns the percent full from twitter
    if user.status:
        text = user.status.text
    else:
        return None
    if (__dehumidifiers__[name].has_key('full') and
        __dehumidifiers__[name].has_key('empty')):
        # Is it full?
        _rg = re.compile(__dehumidifiers__[name]['full'])
        if _rg.match(text):
            return 100
        # Is it empty?
        _rg = re.compile(__dehumidifiers__[name]['empty'])
        if _rg.match(text):
            return 0
    if __dehumidifiers__[name].has_key('level'):
        # grab the level using the regexp
        _rg = re.compile(__dehumidifiers__[name]['level'])
        if _rg.match(text):
            return _rg.match(text).group(1)
    return None

def get_fullness_via_capacitance(name):
    """determines the fullness of a dehumidifier by getting the capacitance
       via serial, then judging how full it really is"""

    # Query the Arduino for capacitance (time out after 10 seconds)
    loopstart = time.time()
    ser = serial.Serial(__dehumidifiers__[name]['serial'], 9600)
    ser.flush()
    results = []
    for test in range(0, 11):
        _ok = False
        while not _ok:
            if time.time() > loopstart+10:
                _ok = True
                break
            row = ser.readline().split()
            # Make sure we have 4 elements (didn't open at bad time)...
            if len(row) == 4:
                # row = [milliseconds, 'mS', capacitance, 'mumbleFarads']
                if row[3] == 'microFarads':
                    results.append(int(row[2]) * 1e-6)
                    sys.stderr.write('%suF, ' % row[2])
                    _ok = True
                elif row[3] == 'nanoFarads':
                    results.append(int(row[2]) * 1e-9)
                    sys.stderr.write('%snF, ' % row[2])
                    _ok = True
                else:
                    sys.stderr.write('try %i failed, ' % test)
    sys.stderr.write('done.\n')
    ser.close()

    if len(results) >= 5:
        # Discard the first and last; take the average.
        tmpresults = results[1:len(results)-1]
        capacitance = sum(results)/len(results)
    else:
        # We did not get 5 values out; abort since our data is likely bad
        return None

    sys.stderr.write('Raw capacitance: %.2e, ' % capacitance)

    # Math thanks to Dawn Lepard <dawn@lepard.ca>:
    # Ctotal = 1/(n*(1/C)), solving for n gives us n = C/Ctotal
    # we ghetto-floor it, /* add 1 for the cap that will never be immersed, */
    # sub it from numcaps to get the quantity of capacitors immersed,
    # and multiply it to turn it into a percentage!
    numcaps = __dehumidifiers__[name]['numcaps']
    capvalue = __dehumidifiers__[name]['capvalue']
    immersed = numcaps - int((capvalue/capacitance) + 0.5)
    waterlevel = (immersed/float(numcaps-1))*100

    # The floor function works well near the ends, but in the middle, the
    # raw looks cleaner.
    rawimmersed = numcaps - (capvalue/capacitance)
    rawwaterlevel = (rawimmersed/float(numcaps-1))*100
    sys.stdout.write("raw.value %i\n" % rawwaterlevel)

    if immersed <= 0:
        # very little capacitance -- bottom of probe isn't even wet
        sys.stderr.write('empty!\n')
        return 0
    elif capacitance > (1/(2*(1/capvalue))):
        # Capacitance is greater than we'd see with 2 caps in series
        sys.stderr.write('full!\n')
        return 100
    elif waterlevel > 33 and waterlevel < 77:
        sys.stderr.write('%f capacitors immersed (raw)\n' % rawimmersed)
        return rawwaterlevel
    else:
        sys.stderr.write('%i capacitors immersed (floor)\n' % immersed)
        return waterlevel

def update_twitter(twittername, twitterpass, fullness):
    """Transmits the current level of fullness to Twitter, if Twitter
       doesn't already have it."""

    sendtweet = False
    # Get the current fullness level, as far as Twitter knows it
    curfullstr = get_fullness_via_twitter(twittername)

    if curfullstr:
        curfull = int(curfullstr)
        sys.stderr.write('Curfull: %i  Fullness: %i\n' % (curfull, fullness))
        if fullness != curfull:
            if fullness == 100:
                sendtweet = True
            if fullness == 0:
                sendtweet = True
            if ((abs(curfull - fullness) > 30) and fullness > 15
              and fullness < 80):
                sendtweet = True

    if sendtweet:
        outgoing = __dehumidifiers__[twittername]['updatetwitter'] % fullness
        api = twitter.Api(username=twittername, password=twitterpass)
        status = api.PostUpdate(outgoing + ' ' + ''.join(random.sample('MOIST',5)))
        if status:
            sys.stderr.write('Twitter: TX %s, RX %s\n' % outgoing, status.text)
            return True
    return False

def main():
    """main function to handle munin fun"""
    myname = os.path.split(sys.argv[0])[-1].split('_')[1]
    if len(sys.argv) > 1 and sys.argv[1] == 'config':
        print_config(myname)
    else:
        if __dehumidifiers__[myname]['type'] == 'twitter':
            if __twitterok__:
                fullness = get_fullness_via_twitter(myname)
            else:
                raise ImportError('Twitter module not found for %s' % myname)
        elif __dehumidifiers__[myname]['type'] == 'capacitance':
            fullness = get_fullness_via_capacitance(myname)
        if type(fullness) is not None:
            print '%s.value %i' % (myname, fullness)
            if 'updatetwitter' in __dehumidifiers__[myname].keys():
                if (__dehumidifiers__[myname]['updatetwitter'] and
                        myname in os.environ.keys()):
                    update_twitter(twittername=myname,
                                   twitterpass=os.environ[myname],
                                   fullness=fullness)

if __name__ == '__main__':
    main()

